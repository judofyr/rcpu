# An example of writing macros in Ruby to automate generating assembler code.
require 'tsort'

module MyMacros
  def jmp dest
    SET pc, dest
  end

  def ret
    SET pc, pop
  end

  def infinite_loop
    start = newlabel
    jmp start
  end

  class MoveSorter
    include TSort
    ARG_REGS = [:A, :B, :C].map { |name| RCPU::Register.new(name) }
    SPILL_REG = RCPU::Register.new(:O)

    Move = Struct.new(:src, :dst, :spill)

    def initialize args
      fail "too many arguments" if args.size > ARG_REGS.size
      used_arg_regs = ARG_REGS[0...(args.size)]
      @spill_move = nil
      @moves = args.zip(used_arg_regs).
        map { |arg,reg| Move.new(arg, reg, false) }.
        reject { |move| move.src == move.dst }
    end

    def tsort_each_node &b
      @moves.each &b
    end

    def tsort_each_child move, &b
      preds = @moves.select { |move2| !move.spill and move.dst == move2.src }
      preds.each &b
    end

    # Move the given register to temporary storage and rewrite reads from it
    # to point to the new location.
    def spill reg
      spill_move = Move.new(reg, SPILL_REG, true)
      @moves.each do |move|
        move.src = SPILL_REG if move.src == reg
      end
      @moves << spill_move
    end

    # Return an array of Move objects in the order they should be executed.
    def sort
      # Find a cycle in the move graph and pick a register to spill to break it.
      spillee = nil
      each_strongly_connected_component do |component|
        if component.size > 1
          fail if spillee # There can only be one cycle with 3 registers.
          spillee = component.first.src
        end
      end

      # Break the cycle.
      spill spillee if spillee

      tsort
    end
  end

  # Implements the calling convention from https://gist.github.com/2313564
  def call dest, *args
    # Split into register and stack args
    stack_args = args.dup
    reg_args = stack_args.slice! 0...3

    # Push all the stack arguments in reverse order
    stack_args.reverse.each { |arg| SET push, arg }

    # Set the argument registers
    MoveSorter.new(reg_args).sort.each do |move|
      SET move.dst, move.src
    end

    JSR dest

    # Clean up the stack arguments
    ADD sp, stack_args.size if stack_args.size > 0
  end
end

# Add the first 6 arguments and return the result
block :add6 do
  extend MyMacros
  ADD a, b
  ADD a, c
  SET b, sp
  ADD a, [b+1]
  ADD a, [b+2]
  ADD a, [b+3]
  ret
end

block :main do
  extend MyMacros

  SET a, 1
  SET b, 2
  SET c, 3
  SET x, 4
  call :_add6, c, a, b, x, 5, [:six]

  infinite_loop

  data :six, [6]
end
